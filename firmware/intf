#!/usr/bin/python 

# Very simple command line interface for development

import math;
import cmd;
import os;
import serial
import time
import traceback

OP_MODE    = 0
OP_PEEK    = 1
OP_POKE    = 2

TERM = 0xf1
ESC  = 0xf2

ser = serial.Serial( port='/dev/ttyUSB0', baudrate=115200 )
ser.timeout = 0.8

class Error(Exception):
   def __init__(self, value):
      self.value = value
   def __str__( self ):
      return self.value;

class cmdline( cmd.Cmd ):
   def __init__( self ):
      cmd.Cmd.__init__( self );
      self.prompt = '] ';
      self.cmdloop();

   def cmdloop( self ):
      while( True ):

	 try:
	    return cmd.Cmd.cmdloop( self );

	 except:
            traceback.print_exc()
	    #print sys.exc_info()
	    pass;

   def do_run( self, line ):
      p = str.split(line);
      if( os.path.exists( p[0] ) ):
	 fname = p[0];
      elif( os.path.exists( 'scripts/' + p[0] ) ):
	 fname = 'scripts/' + p[0];
      else:
	 print 'Unknown file ' + p[0];
	 return;
      gbl = globals().copy();
      gbl['cmdline'] = line;
      gbl['parser'] = self
      execfile( fname, gbl );

   def complete_run( self, text, line, begidx, endidx ):
      return glob.glob( text + '*.py' ) + [x[8:] for x in glob.glob( 'scripts/' + text + '*.py' )];

   def do_exec( self, line ):
      exec(line);

   def do_peek( self, line ):
      """ Peek at a memory location"""
      param = str.split(line);
      addr = 0; ct = 1; fmt = '+XXXX';
      fname = None;
      if( len(param) > 3 ): fname = param[3];
      if( len(param) > 2 ): fmt = param[2];
      if( len(param) > 1 ): ct = int(param[1],0);
      if( len(param) > 0 ): addr = int(param[0],0)
      peek( addr, ct, fmt, fname );

   def do_poke( self, line ):
      param = str.split(line);
      if( len(param) < 2 ): return;
      ldat = False;

      ptype = 'byte'
      if( param[0] in ['long', 'short'] ):
         ptype = param[0]
	 param = param[1:];

      addr = int(param[0],0)
      data = [int(x,0) for x in param[1:] ];
      poke( addr, data, ptype );

   def do_EOF( self, line ):
      return True;

   def do_exit( self, line ):
      return True;

#   def do_reset( self, line ):
#      SendCmd( OP_RESET )

def FmtPeek( dat, fmt='+XXXX', addr=0 ):

   fmtInfo = {
      '+' : ( '0x%08x: ', 0, 'addr' ),
      'x' : ( '0x%04x ',  2, 'GrabU16(dat)' ),
      'i' : ( '%5d ',     2, 'GrabI16(dat)' ),
      'u' : ( '%5u ',     2, 'GrabU16(dat)' ),
      'X' : ( '0x%08x ',  4, 'GrabU32(dat)' ),
      'I' : ( '%9d ',     4, 'GrabI32(dat)' ),
      'U' : ( '%9u ',     4, 'GrabU32(dat)' ),
      'n' : ( '\n',       0, 'None' ),
      'f' : ( '%8.4f ',   4, 'GrabFlt(dat)' ),
      'e' : ( '%12.4e ',   4, 'GrabFlt(dat)' ),
      'c' : ( '%s',       1, 'chr(GrabU8(dat))' ),
      'b' : ( '0x%02x ',  1, 'GrabU8(dat)' ),
   };

   ret = '';
   ndx = -1;
   while( len(dat) > 0 ):
      ndx += 1;
      if( ndx == len(fmt) ):
	 ret += '\n';
	 ndx = 0;

      ch = fmt[ndx];

      if( ch in fmtInfo ):
	 val = eval( fmtInfo[ch][2] );

	 if( val == None ):
	    ret += fmtInfo[ch][0];
	 else:
	    ret += fmtInfo[ch][0] % val;
	 addr += fmtInfo[ch][1];
      else:
	 ret += ch;

   return ret;

def peek( addr, ct=1, fmt='+XXXX', fname=None, raw=False  ):
#   addr = decodeAddr(addr)
#   if( addr == None ):
#      print 'Unknown symbol'
#      return
   out = SendCmd( OP_PEEK, Split32( addr )+[ct] )
   if( raw ): return out

   s = FmtPeek( out, fmt, addr );
   if( fname == None ):
      print s
   else:
      fp = open( fname, 'w' );
      fp.write(s);
      fp.write('\n');
      fp.close()

def peekl( addr, ct=None, le=True, signed=False ):
#   addr = decodeAddr(addr)
#   if( addr == None ):
#      print 'Unknown symbol'
#      return

   if( ct == None ):
      ct = 1;
   out = peek( addr, 4*ct, raw=True )
   return Build32( out, le=True, signed=False )

#def peekf( addr, ct=None ):
#   dat = peekl(addr,ct, le=True, signed=False);
#   if( ct == None ):
#      return Util.I2F(dat)
#   ret = []
#   for d in dat:
#      ret.append( Util.I2F(d) )
#   return ret

def poke( addr, dat, ptype ):
#   addr = decodeAddr(addr)
#   if( addr == None ):
#      print 'Unknown symbol'
#      return
   if( isinstance(dat,int) or isinstance(dat,long) ):
      dat = [dat];

   if( ptype == 'long' ):
      dat = Split32(dat);
   if( ptype == 'short' ):
      dat = Split16(dat);

   SendCmd( OP_POKE, Split32( addr )+dat )

def Cksum( buff ):
   s = 0x55
   for b in buff: s ^= b
   return s

def EscCmd( buff ):
   ret = []
   for i in buff:
      if( i==ESC or i==TERM ):
         ret.append(ESC)
      ret.append(i)
   ret.append(TERM)
   return ret;

def GetResp( show=False ):
   dat = []
   esc = False
   if( show ):
      print 'Getting resp: ',
   while( True ):
      x = ser.read(1)
      if( len(x) < 1 ):
         if( show ):
            print 'timeout'
         return dat
      x = ord(x)
      if( show ):
         print '0x%02x' % x,

      if( esc ):
         esc = False
         dat.append(x)
         continue

      if( x == ESC ):
         esc = True
         continue

      if( x == TERM ):
         if( show ):
            print
         return dat
      dat.append(x)

def SendCmd( op, data=[] ):
   show = False
   global ser
   buff = [op] + data
   buff.insert( 1,Cksum(buff) )

   if( show ):
      S = 'CMD: '
      for b in buff: S += '0x%02x ' % b
      print S

   buff = EscCmd( buff )
   if( show ):
      S = 'ESC: '
      for b in buff: S += '0x%02x ' % b
      print S

   ser.write( ''.join( [chr(x) for x in buff]) )
   rsp = GetResp( show )
   if( len(rsp) < 1 ):
      return rsp
   if( Cksum(rsp) ):
      raise Error( "Checksum" )

   if( len(rsp)>0 and rsp[0] ):
      #raise Error( "Error %d (0x%02x)" % (rsp[0],rsp[0]) )
      print "Error %d (0x%02x)" % (rsp[0],rsp[0]);
      return []
   return rsp[2:]

def SplitInt( val, len=4, le=True, asStr=False ):
   ret = [];

   if( isinstance( val, list ) ):
      for v in val:
         ret += SplitInt( v, len, le, False );
   else:
      for i in range(len):
         ret.append( int(val & 0x00FF) );
         val >>= 8;

      if( not le ): ret = ret[::-1];
   if( asStr ): ret = "".join([chr(i) for i in ret]);
   return ret;

def Split16( x, le=True, asStr=False ): return SplitInt( x, 2, le, asStr );
def Split32( x, le=True, asStr=False ): return SplitInt( x, 4, le, asStr );

# Utility function to convert bytes to ints
def MakeInt( bytes, signed=True, le=True ):
   if( not le ): bytes = bytes[::-1];
   val = 0;
   shift = 0;
   for b in bytes:
      val |= (b<<shift);
      shift += 8;

   if( signed and bytes[-1] & 0x80 ):
      return val - (1<<shift)
   return val

def Build32( dat, le=True, signed=False ):
   ret = [];
   for i in range( len(dat)/4 ):
      ret.append( MakeInt( dat[ (4*i):(4*i+4) ], signed=signed, le=le ) );
   return ret;

def GrabElems( dat, ct ):
   if( len(dat) < ct ):
      dat.extend( (ct-len(dat))*[0] );
   ret = dat[:ct];
   del dat[0:ct];
   return ret;

def GrabI8( dat, le=True ):  return MakeInt( GrabElems(dat,1), signed=True,  le=le );
def GrabU8( dat, le=True ):  return MakeInt( GrabElems(dat,1), signed=False, le=le );
def GrabI16( dat, le=True ): return MakeInt( GrabElems(dat,2), signed=True,  le=le );
def GrabU16( dat, le=True ): return MakeInt( GrabElems(dat,2), signed=False, le=le );
def GrabI24( dat, le=True ): return MakeInt( GrabElems(dat,3), signed=True,  le=le );
def GrabU24( dat, le=True ): return MakeInt( GrabElems(dat,3), signed=False, le=le );
def GrabI32( dat, le=True ): return MakeInt( GrabElems(dat,4), signed=True,  le=le );
def GrabU32( dat, le=True ): return MakeInt( GrabElems(dat,4), signed=False, le=le );
def GrabI64( dat, le=True ): return MakeInt( GrabElems(dat,8), signed=True,  le=le );
def GrabU64( dat, le=True ): return MakeInt( GrabElems(dat,8), signed=False, le=le );
def GrabFlt( dat, le=True ): return I2F( GrabU32(dat, le=le) );

cmdline();

